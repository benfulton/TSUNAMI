#                   quote = input$quote)
data_temp = as.matrix(readLines("/Users/zhi/Desktop/GSE17537.txt"), sep = '\n')
data_temp = strsplit(data_temp, split=input$sep)
data_temp = strsplit(data_temp, split="\t")
max.length <- max(sapply(data_temp, length))
data_temp <- lapply(data_temp, function(v) { c(v, rep(NA, max.length-length(v)))})
data_temp <- data.frame(do.call(rbind, data_temp))
dim(data_temp)
data_temp[54752]
data_temp[54752,]
data_temp[dim(data_temp)[1],1]
if(data_temp[dim(data_temp)[1],1] == "!series_matrix_table_end"){
print("remove last row with \"!series_matrix_table_end\" ")
}
if(data_temp[dim(data_temp)[1],1] == "!series_matrix_table_end"){
print("remove last row with \"!series_matrix_table_end\" ")
data_temp[-dim(data_temp)[1]]
}
# data <<- read.csv(input$csvfile$datapath,
#                   header = input$header,
#                   sep = input$sep,
#                   quote = input$quote)
data_temp = as.matrix(readLines("/Users/zhi/Desktop/GSE17537.txt"), sep = '\n')
data_temp = strsplit(data_temp, split="\t")
max.length <- max(sapply(data_temp, length))
data_temp <- lapply(data_temp, function(v) { c(v, rep(NA, max.length-length(v)))})
data_temp <- data.frame(do.call(rbind, data_temp))
if(data_temp[dim(data_temp)[1],1] == "!series_matrix_table_end"){
print("remove last row with \"!series_matrix_table_end\" ")
data_temp[-dim(data_temp)[1],]
}
if(data_temp[dim(data_temp)[1],1] == "!series_matrix_table_end"){
print("remove last row with \"!series_matrix_table_end\" ")
data_temp = data_temp[-dim(data_temp)[1],]
}
dim(data_temp)
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
load("/Users/zhi/Desktop/fname.Rdata")
length(fname)
gpltable
gpltable$`Gene Symbol`
if (!is.null(gpltable$`Gene Symbol`)){
print("load GPL table with name \"Gene Symbol\"")
for (i in 1:length(fname)){
fname2[i] <- gpltable$`Gene Symbol`[which(gpltable$ID == fname[i])]
}
}
print(length(fname2))
print(dim(data))
print(length(fname))
fname2 <- fname
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
genes_str <- c('PHF|14','RBM|3','Nlrx1','MSL1','PHF21A','ARL10','INSR')
return(paste(genes_str, collapse = '\n'))
paste(genes_str, collapse = '\n')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
ological_Process_2017b",
"GO_Molecular_Function_2017b",
"GO_Cellular_Component_2017b",
"Jensen_DISEASES",
"Reactome_2016",
"KEGG_2016",
"Transcription_Factor_PPIs",
"TargetScan_microRNA_2017")
enrichr_dbs <- c("GO_Biological_Process_2017b",
"GO_Molecular_Function_2017b",
"GO_Cellular_Component_2017b",
"Jensen_DISEASES",
"Reactome_2016",
"KEGG_2016",
"Transcription_Factor_PPIs",
"TargetScan_microRNA_2017")
paste0(enrichr_dbs, '.csv')
for(i in 1:10){
print(i)
}
for(i in 1:length(enrichr_dbs)){
print(i)
}
for(i in 1:length(enrichr_dbs)){
print(enrichr_dbs[i])#enriched
}
if(separator == ','){
fs <- paste0(enrichr_dbs, '.csv')
}
separator = ','
if(separator == ','){
fs <- paste0(enrichr_dbs, '.csv')
}
fs
for(i in 1:length(enrichr_dbs)){
print(fs[i])#enriched
}
enriched
zip
file.rename
fname = "fname"
if(file.exists(paste0(fname, ".zip"))) {file.rename(paste0(fname, ".zip"), fname)}
file.rename(paste0(fname, ".zip"), fname)
file.exists(paste0(fname, ".zip"))
runApp('Desktop/GeneCoexpression/RGUI_v5')
fs
fs = c(fs, 'genes_list.txt')
fs
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
runApp('Desktop/GeneCoexpression/RGUI_v5')
system("which python") # python version should be from Anaconda2
print(sprintf("Current Python Version: %s", system("which python"))
)
system("which python")
print("Current Python Version:")
system("which python")
# 03/13/2017 Zhi Huang
library(shiny)
library(rsconnect)
library(plyr)
library(data.table)
library(genefilter)
library(Biobase)
library(rPython)
library(WGCNA)
library(GEOquery)
library(dplyr)
library(enrichR)
library(DT)
library(reticulate)
use_python("/Users/zhi/anaconda2/bin/python")
setwd('/Users/zhi/Desktop/GeneCoexpression/RGUI_v5/')
data <- NULL
GEO <- NULL
finalExp <- NULL
finalSym <- NULL
finalSymChar <- NULL
text <- NULL
geneCharVector_global <- NULL
eigengene_matrix <- NULL
#   +------------------------------------------------------------+
#   |
#   |
#   |                         Load Data
#   |
#   |
#   +--------------------------------
data_in = as.matrix(readLines('../matlab_old/RNAdata.csv'), sep = '\n')
data_temp = strsplit(data_in, split=",")
max.length <- max(sapply(data_temp, length))
data_temp <- lapply(data_temp, function(v) { c(v, rep(NA, max.length-length(v)))})
data_temp <- data.frame(do.call(rbind, data_temp))
if(data_temp[dim(data_temp)[1],1] == "!series_matrix_table_end"){
print("remove last row with \"!series_matrix_table_end\" ")
data_temp = data_temp[-dim(data_temp)[1],]
}
data <- data_temp[-1,]
print("CSV / txt file Processed.")
print(sprintf("Number of Genes: %d",dim(data)[1]))
print(sprintf("Number of Samples: %d",(dim(data)[2]-1)))
#   +------------------------------------------------------------+
#   |
#   |
#   |                      Cleaning the Data
#   |
#   |
#   +--------------------------------
source("utils.R")
RNA <- as.matrix(data[, 2:dim(data)[2]])
class(RNA) <- "numeric"
geneID <- data.frame(data[, 1])
print(dim(RNA))
print(dim(geneID))
# convert na to 0
RNA[is.na(RNA)] <- 0
# Remove data with lowest 20% absolute exp value shared by all samples
percentile <- 20/100.
# save(RNA, file="/Users/zhi/Desktop/RNA.Rdata")
if (percentile > 0){
RNA_filtered1 = RNA[apply(RNA,1,max) > quantile(RNA, percentile)[[1]], ]
geneID_filtered1 = geneID[apply(RNA,1,max) > quantile(RNA, percentile)[[1]], ]
} else {
RNA_filtered1 = RNA
geneID_filtered1 = geneID
}
print(dim(RNA_filtered1))
# Remove data with lowest 10% variance across samples
percentile <- 9.99/100.
if (percentile > 0){
index <- varFilter2(eset = RNA_filtered1, var.cutoff = percentile)
RNA_filtered2 = RNA_filtered1[index, ]
geneID_filtered2 = geneID_filtered1[index]
} else {
RNA_filtered2 = RNA_filtered1
geneID_filtered2 = geneID_filtered1
}
print(dim(RNA_filtered2))
uniGene <- geneID_filtered2
tmpExp <- RNA_filtered2
nSample <- ncol(tmpExp)
res <- sort.int(rowMeans(tmpExp), decreasing = TRUE, index.return=TRUE)
sortMean <- res$x
sortInd <- res$ix
topN <- min(2000, nrow(tmpExp))
finalExp <- tmpExp[sortInd[1:topN], ]
finalSym <- uniGene[sortInd[1:topN]]
finalSymChar <- as.character(finalSym)
#   +------------------------------------------------------------+
#   |
#   |
#   |                         l m Q C M
#   |
#   |
#   +--------------------------------
step1 = 1
gamma = 0.55
t = 1
lambda = 1
beta = 0.4
minClusterSize = 10
massiveCC = 'Pearson'
head(finalExp)
cor_mat = cor(finalExp)
head(cor_mat)
dim(cor_mat)
cor_mat = cor(t(finalExp))
dim(cor_mat)
cor_mat[1:6,1:6]
cor_mat = cor(t(finalExp), method = c("pearson", "kendall", "spearman"))
cor_mat
dim(cor_mat)
cor_mat[1:6,1:6]
cor_mat = cor(t(finalExp), method = "spearman")
cor_mat[1:6,1:6]
head(finalExp)
data_in = finalExp
rownames(data_in)
cMatrix = cor(t(data_in), method = CCmethod)
CCmethod="pearson"
print("Calculating massive correlation coefficient ...")
cMatrix = cor(t(data_in), method = CCmethod)
C <- localMaximumQCM(cMatrix, gamma, t, lambda)
localMaximumQCM <- function (cMatrix, gamma, t, lambda){
C <- list()
nRow <- nrow(cMatrix)
maxV <- apply(cMatrix, 2, max)
maxInd <- apply(cMatrix, 2, which.max) # several diferrences comparing with Matlab results
# Step 1 - find the local maximal edges
maxEdges <- matrix(0, nrow = 0, ncol = 2)
maxW <- matrix(0, nrow = 0, ncol = 1)
for (i in 1:nRow){
if (maxV[i] == max(cMatrix[maxInd[i], ])) {
maxEdges <- rbind(maxEdges, c(maxInd[i], i))
maxW <- rbind(maxW, maxV[i])
}
}
res <- sort.int(maxW, decreasing = TRUE, index.return=TRUE)
sortMaxV <- res$x
sortMaxInd <- res$ix
sortMaxEdges <- maxEdges[sortMaxInd,]
print(sprintf("Number of Maximum Edges: %d", length(sortMaxInd)))
currentInit <- 1
noNewInit <- 0
nodesInCluster <- matrix(0, nrow = 0, ncol = 1)
while ((currentInit <= length(sortMaxInd)) & (noNewInit == 0)) {
if (sortMaxV[currentInit] < (gamma * sortMaxV[1]) ) {
noNewInit <- 1
}
else {
if ( (is.element(sortMaxEdges[currentInit, 1], nodesInCluster) == FALSE) & is.element(sortMaxEdges[currentInit, 2], nodesInCluster) == FALSE) {
newCluster <- sortMaxEdges[currentInit, ]
addingMode <- 1
currentDensity <- sortMaxV[currentInit]
nCp <- 2
totalInd <- 1:nRow
remainInd <- setdiff(totalInd, newCluster)
# C = setdiff(A,B) for vectors A and B, returns the values in A that
# are not in B with no repetitions. C will be sorted.
while (addingMode == 1) {
neighborWeights <- colSums(cMatrix[newCluster, remainInd])
maxNeighborWeight <- max(neighborWeights)
maxNeighborInd <- which.is.max(neighborWeights)
c_v = maxNeighborWeight/nCp;
alphaN = 1 - 1/(2*lambda*(nCp+t));
if (c_v >= alphaN * currentDensity) {
newCluster <- c(newCluster, remainInd[maxNeighborInd])
nCp <- nCp + 1
currentDensity <- (currentDensity*((nCp-1)*(nCp-2)/2)+maxNeighborWeight)/(nCp*(nCp-1)/2)
remainInd = setdiff(remainInd, remainInd[maxNeighborInd]);
}
else {
addingMode <- 0
}
}
nodesInCluster <- c(nodesInCluster, newCluster)
C <- c(C, list(newCluster))
}
}
currentInit <- currentInit + 1
}
return(C)
}
C <- localMaximumQCM(cMatrix, gamma, t, lambda)
C
View(C)
data_in
head(cMatrix)
cMatrix = cor(t(data_in), method = CCmethod)
cMatrix[1:5,1:5]
diag(cMatrix) <- 0
cMatrix[1:5,1:5]
C <- localMaximumQCM(cMatrix, gamma, t, lambda)
C
View(C)
C_save <- C
C <- C_save
C
sizeC <- matrix(0, nrow = 0, ncol = length(C))
sizeC
sizeC[1]
sizeC[2]
sizeC[3]
for (i in 1:length(C)){
sizeC[i] <- length(C[[i]])
}
sizeC
sizeC
res <- sort.int(sizeC, decreasing = TRUE, index.return=TRUE)
sortC <- res$x
sortInd <- res$ix
C <- C[sortInd] # Still C, but sorted based on number of elements in each cell
C
View(C)
head(C)
head(C_save)
title(C)
rownames)C)
rownames(C)
colnames(C)
res <- sort.int(sizeC, decreasing = TRUE, index.return=TRUE)
sortC <- res$x
sortInd <- res$ix
sortC
ind <- which(sortC >= minClusterSize)
mergedCluster <- C[ind]
mergeOccur <- 1
currentInd <- 0
print("start merge")
while (mergeOccur == 1) {
mergeOccur <- 0
while (currentInd < length(mergedCluster)){
currentInd <- currentInd + 1
if (currentInd < length(mergedCluster)){
keepInd <- 1:currentInd
for (j in (currentInd+1) : length(mergedCluster)) {
interCluster <- intersect(mergedCluster[[currentInd]], mergedCluster[[j]]);
if (length(interCluster) >= beta*min(length(mergedCluster[[j]]), length(mergedCluster[[currentInd]]))) {
mergedCluster[currentInd] <- list(union(mergedCluster[[currentInd]], mergedCluster[[j]]))
mergeOccur <- 1
}
else {
keepInd <- c(keepInd, j)
}
}
mergedCluster <- mergedCluster[keepInd]
print(sprintf("The length of merged Cluster: %d", length(mergedCluster)))
}
}
sizeMergedCluster <- matrix(0, nrow = 0, ncol = length(mergedCluster))
for (i in 1 : length(mergedCluster)) {
sizeMergedCluster[i] <- length(mergedCluster[[i]])
}
res <- sort.int(sizeMergedCluster, decreasing = TRUE, index.return=TRUE)
sortSize <- res$x
sortMergedInd <- res$ix
mergedCluster <- mergedCluster[sortMergedInd]
currentInd <- 0
}
View(mergedCluster)
# 03/14/2018 1:59PM The Pi Day
# Author: Zhi Huang
library(genefilter)
library(Biobase)
localMaximumQCM <- function (cMatrix, gamma, t, lambda){
C <- list()
nRow <- nrow(cMatrix)
maxV <- apply(cMatrix, 2, max)
maxInd <- apply(cMatrix, 2, which.max) # several diferrences comparing with Matlab results
# Step 1 - find the local maximal edges
maxEdges <- matrix(0, nrow = 0, ncol = 2)
maxW <- matrix(0, nrow = 0, ncol = 1)
for (i in 1:nRow){
if (maxV[i] == max(cMatrix[maxInd[i], ])) {
maxEdges <- rbind(maxEdges, c(maxInd[i], i))
maxW <- rbind(maxW, maxV[i])
}
}
res <- sort.int(maxW, decreasing = TRUE, index.return=TRUE)
sortMaxV <- res$x
sortMaxInd <- res$ix
sortMaxEdges <- maxEdges[sortMaxInd,]
print(sprintf("Number of Maximum Edges: %d", length(sortMaxInd)))
currentInit <- 1
noNewInit <- 0
nodesInCluster <- matrix(0, nrow = 0, ncol = 1)
while ((currentInit <= length(sortMaxInd)) & (noNewInit == 0)) {
if (sortMaxV[currentInit] < (gamma * sortMaxV[1]) ) {
noNewInit <- 1
}
else {
if ( (is.element(sortMaxEdges[currentInit, 1], nodesInCluster) == FALSE) & is.element(sortMaxEdges[currentInit, 2], nodesInCluster) == FALSE) {
newCluster <- sortMaxEdges[currentInit, ]
addingMode <- 1
currentDensity <- sortMaxV[currentInit]
nCp <- 2
totalInd <- 1:nRow
remainInd <- setdiff(totalInd, newCluster)
# C = setdiff(A,B) for vectors A and B, returns the values in A that
# are not in B with no repetitions. C will be sorted.
while (addingMode == 1) {
neighborWeights <- colSums(cMatrix[newCluster, remainInd])
maxNeighborWeight <- max(neighborWeights)
maxNeighborInd <- which.is.max(neighborWeights)
c_v = maxNeighborWeight/nCp;
alphaN = 1 - 1/(2*lambda*(nCp+t));
if (c_v >= alphaN * currentDensity) {
newCluster <- c(newCluster, remainInd[maxNeighborInd])
nCp <- nCp + 1
currentDensity <- (currentDensity*((nCp-1)*(nCp-2)/2)+maxNeighborWeight)/(nCp*(nCp-1)/2)
remainInd = setdiff(remainInd, remainInd[maxNeighborInd]);
}
else {
addingMode <- 0
}
}
nodesInCluster <- c(nodesInCluster, newCluster)
C <- c(C, list(newCluster))
}
}
currentInit <- currentInit + 1
}
return(C)
}
merging_lmQCM <- function(C, beta, minClusterSize){
# Merge the overlapped networks
sizeC <- matrix(0, nrow = 0, ncol = length(C))
for (i in 1:length(C)){
sizeC[i] <- length(C[[i]])
}
res <- sort.int(sizeC, decreasing = TRUE, index.return=TRUE)
sortC <- res$x
sortInd <- res$ix
C <- C[sortInd] # Still C, but sorted based on number of elements in each cell
ind <- which(sortC >= minClusterSize)
mergedCluster <- C[ind]
mergeOccur <- 1
currentInd <- 0
print("start merge")
while (mergeOccur == 1) {
mergeOccur <- 0
while (currentInd < length(mergedCluster)){
currentInd <- currentInd + 1
if (currentInd < length(mergedCluster)){
keepInd <- 1:currentInd
for (j in (currentInd+1) : length(mergedCluster)) {
interCluster <- intersect(mergedCluster[[currentInd]], mergedCluster[[j]]);
if (length(interCluster) >= beta*min(length(mergedCluster[[j]]), length(mergedCluster[[currentInd]]))) {
mergedCluster[currentInd] <- list(union(mergedCluster[[currentInd]], mergedCluster[[j]]))
mergeOccur <- 1
}
else {
keepInd <- c(keepInd, j)
}
}
mergedCluster <- mergedCluster[keepInd]
print(sprintf("The length of merged Cluster: %d", length(mergedCluster)))
}
}
sizeMergedCluster <- matrix(0, nrow = 0, ncol = length(mergedCluster))
for (i in 1 : length(mergedCluster)) {
sizeMergedCluster[i] <- length(mergedCluster[[i]])
}
res <- sort.int(sizeMergedCluster, decreasing = TRUE, index.return=TRUE)
sortSize <- res$x
sortMergedInd <- res$ix
mergedCluster <- mergedCluster[sortMergedInd]
currentInd <- 0
}
return(mergedCluster)
}
lmQCM <- function(data_in, gamma,t,lambda,beta,minClusterSize, CCmethod="pearson") {
print("Calculating massive correlation coefficient ...")
cMatrix = cor(t(data_in), method = CCmethod)
diag(cMatrix) <- 0
C <- localMaximumQCM(cMatrix, gamma, t, lambda)
mergedCluster <- merging_lmQCM(C, beta, minClusterSize)
return(mergedCluster)
}
lmQCM(finalExp, gamma,t,lambda,beta,minClusterSize, CCmethod="pearson")
mergedCluster = lmQCM(finalExp, gamma,t,lambda,beta,minClusterSize, CCmethod="pearson")
View(mergedCluster)
